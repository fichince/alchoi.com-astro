---
title: My fourth-year ray tracer project
description: Even back then, I loved pool
date: 2023-06-20
tags:
  - coding
  - tech
  - fun
image: ../../images/blog/cow.png
---

When I attended the University of Waterloo 20-ish years ago, all of the Computer Science undergrads, myself included, feared the so-called "Big 3," courses that were so hard as to drive students mad: **Real-time Programming**, **Compilers**, and **Computer Graphics**. 

When it came time to select my courses for fourth year, I knew I wanted to try one of them. I had a friend who dreamed of one day working on video games, so we decided to take the Graphics course together.

The final project involved creating a [ray tracer](https://en.wikipedia.org/wiki/Ray_tracing_(graphics)). After feverishly writing code for weeks, and a lot of time waiting for images to render, the final submission took the form of an image gallery. I remember being very proud of what I'd made. I still have all of the files, and there's no point keeping them hidden in the digital attic, so here I present my final project for CS488.

(Aside: the thumbnail image for this post that you see above was AI-generated by Stable Diffusion using the prompt: _a cow carved out of wood, 3d render_.)

----

## New primitives

New cylinder and cone primitives were created.

![](../../images/blog/cs488/newprimitives.png)

The radius and height of the primitives can be adjusted to create a variety of shapes.

<div class="responsive-gallery tw-not-prose">

![](../../images/blog/cs488/cylinderprimitives.png)

![](../../images/blog/cs488/coneprimitives.png)

</div>

## Reflections

This image shows reflections. The good ol' "hallway of mirrors"...

![](../../images/blog/cs488/reflection-redball.png)

This time, the ball itself is reflective, too.

![](../../images/blog/cs488/reflection-mirrorball.png)

## Refraction

The following sequence shows a refractive pane of glass with progressively larger indices of refraction.

![](../../images/blog/cs488/refraction1.0.png)
<small>Refraction index 1.0 - Light rays do not get bent at all.</small>

<div class="responsive-gallery tw-not-prose">

<div>

![](../../images/blog/cs488/refraction1.3.png)
<small>Refraction index 1.3</small>
</div>

<div>

![](../../images/blog/cs488/refraction1.5.png)
<small>Refraction index 1.5</small>
</div>

<div>

![](../../images/blog/cs488/refraction1.8.png)
<small>Refraction index 1.8</small>
</div>

<div>

![](../../images/blog/cs488/refraction2.0.png)
<small>Refraction index 2.0</small>
</div>

<div>

![](../../images/blog/cs488/refraction2.5.png)
<small>Refraction index 2.5</small>
</div>

</div>

## Texture mapping with images

Texture maps can be applied to all primitives except polygonal meshes.

<div class="responsive-gallery tw-not-prose">

![](../../images/blog/cs488/brick.jpg)

![](../../images/blog/cs488/texture_brick.png)

</div>

<br />

<div class="responsive-gallery tw-not-prose">

![](../../images/blog/cs488/earth_tn.jpg)

![](../../images/blog/cs488/texture_earth.png)

</div>

## Texture mapping with Perlin noise

Perlin noise functions create pseudorandom textures. The noise functions can be used to achieve many types of textures:

### Pure noise

"Pure" noise gives a sort of dirty look to the texture. Different values for the persistence parameter achieves varying levels of noisiness.

<div class="responsive-gallery tw-not-prose">

<div>

![](../../images/blog/cs488/noise_pure0.2.png)
<small>Persistence 0.2</small>
</div>

<div>

![](../../images/blog/cs488/noise_pure0.5.png)
<small>Persistence 0.5</small>
</div>

<div>

![](../../images/blog/cs488/noise_pure0.8.png)
<small>Persistence 0.8</small>
</div>

</div>

I have implemented Perlin noise to allow flexibility in the colours that the texture is made of. Here is an example of using different colours:

![](../../images/blog/cs488/noise_pure_colour.png)

### Wood grain

Perlin noise can be used to generate wood grain textures. Wood textures work best with low values for persistence; otherwise, the grain is much too chaotic.

<div class="responsive-gallery tw-not-prose">

<div>

![](../../images/blog/cs488/noise_wood0.1.png)
<small>Persistence 0.1</small>
</div>

<div>

![](../../images/blog/cs488/noise_wood0.2.png)
<small>Persistence 0.2</small>
</div>

<div>

![](../../images/blog/cs488/noise_wood0.5.png)
<small>Persistence 0.5 - It's starting to get ugly</small>
</div>

<div>

![](../../images/blog/cs488/noise_wood0.8.png)
<small>Persistence 0.8 - Does not look like wood anymore</small>
</div>

</div>

We can still specify colours for wood grain textures. So, it is possible to create this "psychedelic" wood:
![](../../images/blog/cs488/noise_wood_colour.png)

### Marble

Marble textures can be created with Perlin noise. Marble looks best with high values of persistence. Also, it looks most natural if the two colours of the texture are close in shade.

<div class="responsive-gallery tw-not-prose">

<div>

![](../../images/blog/cs488/noise_marble0.3.png)
<small>Persistence 0.3 - This doesn't look like marble yet</small>
</div>

<div>

![](../../images/blog/cs488/noise_marble1.0.png)
<small>Persistence 1.0 - Better</small>
</div>

<div>

![](../../images/blog/cs488/noise_marble1.3.png)
<small>Persistence 1.3 - (Arguably) better still</small>
</div>

<div>

![](../../images/blog/cs488/noise_marble1.8.png)
<small>Persistence 1.8 - Too chaotic</small>
</div>

</div>

Perlin noise can be applied to all primitives, as demonstrated here.

![](../../images/blog/cs488/noise_allprimitives.png)

It is very difficult to texture map an arbitrary 2-dimensional image to an arbitrary 3-dimensional shape.  However, since Perlin noise is defined in 3 dimensions, it is possible to texture map complex polygonal meshes with noise.  Here, we see a mesh model textured mapped with wood grain and marble textures.

<div class="responsive-gallery tw-not-prose">

![](../../images/blog/cs488/noise_wood_cow.png)

![](../../images/blog/cs488/noise_marble_cow.png)

</div>

## Soft Shadows

Soft shadows can be created using area lights.  Area lights can be partially blocked by objects, which gives the shadow a penumbra and umbra.


![](../../images/blog/cs488/softshadowpointlight.png)
<small>
For comparison, this is what a "hard" shadow looks like, as created by a single point light source.
</small>

Area lights are specified as an n x n array of lights.  The larger the value of n, the better the shadow will look.

<div class="responsive-gallery tw-not-prose">

<div>

![](../../images/blog/cs488/softshadow2lights.png)
<small>2 &times; 2 area light</small>
</div>

<div>

![](../../images/blog/cs488/softshadow5lights.png)
<small>5 &times; 5 area light</small>
</div>

<div>

![](../../images/blog/cs488/softshadow10lights.png)
<small>10 &times; 10 area light</small>
</div>

</div>

The size of the light can also be changed.  Larger lights cast softer shadows, and smaller lights cast harder shadows.

<div class="responsive-gallery tw-not-prose">
<div>

![](../../images/blog/cs488/softshadow1size.png)
<small>A small area light looks almost like a point light source.</small>
</div>

<div>

![](../../images/blog/cs488/softshadow2size.png)
<small>A large area light casts an extremely blurry shadow.</small>
</div>
</div>

The size of the light can vary in either direction.  Compare these two images: one is a "wide" light, and the other is a "tall" light.

<div class="responsive-gallery tw-not-prose">

![](../../images/blog/cs488/softshadow3size.png)

![](../../images/blog/cs488/softshadow4size.png)

</div>

## Glossiness

Glossy reflections are accomplished by distributing a reflection among many reflection rays.  The more reflection rays there are, the better the reflection will look.

![](../../images/blog/cs488/glossiness1rays.png)
<small>For comparison, this is a pure, non-glossy reflection.</small>

The following sequence shows the effect of increasing the number of rays.

<div class="responsive-gallery tw-not-prose">

<div>

![](../../images/blog/cs488/glossiness2rays.png)
<small>2 reflection rays</small>
</div>

<div>

![](../../images/blog/cs488/glossiness10rays.png)
<small>10 reflection rays</small>
</div>

<div>

![](../../images/blog/cs488/glossiness50rays.png)
<small>50 reflection rays</small>
</div>
</div>

We can control how scattered the reflection rays are.  This is determined by the specular reflection coefficient of the material.  The higher the specular coefficient, the sharper the reflection.

<div class="responsive-gallery tw-not-prose">

<div>

![](../../images/blog/cs488/glossiness10specular.png)
<small>Specular coefficient 10</small>
</div>

<div>

![](../../images/blog/cs488/glossiness40specular.png)
<small>Specular coefficient 40</small>
</div>

<div>

![](../../images/blog/cs488/glossiness70specular.png)
<small>Specular coefficient 70</small>
</div>

<div>

![](../../images/blog/cs488/glossiness100specular.png)
<small>Specular coefficient 100</small>
</div>
</div>

## Final Scene

My final scene depicts a pool room.  Texture mapping is used for most of the objects, most obviously on the walls, and in the painting.  The frame of the table is texture-mapped with wood grain generated from Perlin noise.  Notice also that the surface of the table is not completely uniform in colour; this was also accomplished with Perlin noise.

![](../../images/blog/cs488/scene.png)

![](../../images/blog/cs488/ball2.jpg)
<small>Homemade texture for the balls</small>

This is a close-up rendering of the table which more clearly displays the reflectiveness of the balls.  Also, area lights were used to render this scene.

![](../../images/blog/cs488/table.png)